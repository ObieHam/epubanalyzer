import React, { useState, useEffect } from 'react';
import { Upload, User, Book, AlertCircle, Download } from 'lucide-react';

const EpubCharacterAnalyzer = () => {
  const [file, setFile] = useState(null);
  const [analyzing, setAnalyzing] = useState(false);
  const [characters, setCharacters] = useState([]);
  const [error, setError] = useState('');
  const [jszipLoaded, setJszipLoaded] = useState(false);

  // Load JSZip dynamically
  useEffect(() => {
    if (window.JSZip) {
      setJszipLoaded(true);
      return;
    }

    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
    script.async = true;
    script.onload = () => {
      setJszipLoaded(true);
    };
    script.onerror = () => {
      setError('Failed to load required library. Please refresh the page.');
    };
    document.head.appendChild(script);

    return () => {
      if (script.parentNode) {
        document.head.removeChild(script);
      }
    };
  }, []);

  // Comprehensive physical descriptor categories
  const descriptorPatterns = {
    body: [
      'curvy', 'curvaceous', 'voluptuous', 'shapely', 'hourglass', 'petite', 'slender', 'slim', 'thin', 'skinny', 'gaunt', 
      'lean', 'athletic', 'muscular', 'toned', 'fit', 'buff', 'ripped', 'stocky', 'burly', 'heavyset', 'plump', 'chubby', 
      'overweight', 'obese', 'portly', 'stout', 'rotund', 'brawny', 'broad-shouldered', 'narrow-shouldered', 'willowy',
      'lanky', 'gangly', 'scrawny', 'wiry', 'lithe', 'graceful', 'statuesque', 'imposing', 'compact', 'sturdy'
    ],
    
    chest: [
      'big breasts', 'large breasts', 'small breasts', 'flat-chested', 'well-endowed', 'busty', 'ample bosom',
      'full-figured', 'buxom', 'large bust', 'small bust', 'generous bust', 'modest bust', 'full chest', 'barrel-chested',
      'broad chest', 'narrow chest', 'deep chest', 'flat chest', 'muscular chest', 'hairy chest'
    ],
    
    height: [
      'tall', 'short', 'towering', 'diminutive', 'giant', 'tiny', 'average height', 'medium height',
      'six feet', 'five feet', 'over six feet', 'under five feet', 'vertically challenged'
    ],
    
    hair: [
      'blonde', 'brunette', 'redhead', 'ginger', 'auburn', 'black hair', 'dark hair', 'light hair', 'brown hair',
      'gray hair', 'grey hair', 'white hair', 'silver hair', 'salt and pepper', 'graying', 'greying', 'bald', 'balding',
      'long hair', 'short hair', 'shoulder-length', 'waist-length', 'cropped', 'buzz cut', 'crew cut',
      'curly', 'straight', 'wavy', 'kinky', 'frizzy', 'silky', 'coarse', 'fine', 'thick', 'thin hair',
      'ponytail', 'braid', 'braided', 'dreadlocks', 'afro', 'mohawk', 'bob cut'
    ],
    
    eyes: [
      'blue eyes', 'green eyes', 'brown eyes', 'hazel eyes', 'gray eyes', 'grey eyes', 'amber eyes', 'dark eyes',
      'light eyes', 'bright eyes', 'pale eyes', 'piercing eyes', 'almond-shaped', 'round eyes', 'close-set',
      'wide-set', 'deep-set', 'hooded eyes', 'droopy eyes', 'upturned eyes', 'downturned eyes'
    ],
    
    skin: [
      'pale', 'fair', 'light', 'dark', 'tan', 'tanned', 'olive', 'bronze', 'ebony', 'ivory', 'porcelain',
      'creamy', 'ruddy', 'rosy', 'sallow', 'freckled', 'spotted', 'blemished', 'clear skin', 'smooth skin',
      'rough skin', 'weathered', 'wrinkled', 'sun-kissed', 'alabaster'
    ],
    
    face: [
      'beautiful', 'handsome', 'pretty', 'attractive', 'gorgeous', 'stunning', 'striking', 'plain', 'homely', 'ugly',
      'round face', 'oval face', 'square face', 'heart-shaped', 'angular', 'chiseled', 'soft features', 'sharp features',
      'high cheekbones', 'prominent cheekbones', 'hollow cheeks', 'chubby cheeks', 'dimples', 'dimpled',
      'strong jaw', 'weak chin', 'square jaw', 'pointed chin', 'cleft chin', 'double chin',
      'full lips', 'thin lips', 'pouty lips', 'wide mouth', 'small mouth', 'crooked smile',
      'big nose', 'small nose', 'aquiline nose', 'button nose', 'hooked nose', 'Roman nose', 'snub nose',
      'thick eyebrows', 'thin eyebrows', 'arched eyebrows', 'bushy eyebrows', 'unibrow'
    ],
    
    facialHair: [
      'beard', 'bearded', 'goatee', 'mustache', 'moustache', 'clean-shaven', 'stubble', 'five o\'clock shadow',
      'sideburns', 'mutton chops', 'full beard', 'scraggly beard', 'neatly trimmed'
    ],
    
    bodyParts: [
      'long legs', 'short legs', 'thick thighs', 'thin legs', 'muscular legs', 'shapely legs', 'skinny legs',
      'long arms', 'short arms', 'muscular arms', 'thin arms', 'hairy arms',
      'big hands', 'small hands', 'delicate hands', 'rough hands', 'calloused', 'slender fingers', 'thick fingers',
      'small feet', 'large feet', 'dainty feet',
      'broad hips', 'narrow hips', 'wide hips', 'child-bearing hips',
      'flat stomach', 'toned stomach', 'pot belly', 'six-pack', 'abs', 'love handles',
      'round bottom', 'flat bottom', 'pert behind', 'wide rear', 'muscular buttocks',
      'thick neck', 'long neck', 'swan neck', 'bull neck'
    ],
    
    age: [
      'young', 'old', 'elderly', 'ancient', 'youthful', 'middle-aged', 'mature', 'aging', 'ageless',
      'teenage', 'adolescent', 'twenties', 'thirties', 'forties', 'fifties', 'sixties', 'seventies'
    ],
    
    marks: [
      'scar', 'scarred', 'birthmark', 'mole', 'tattoo', 'tattooed', 'piercing', 'pierced',
      'missing tooth', 'gold tooth', 'crooked teeth', 'perfect teeth', 'gap-toothed'
    ],
    
    overall: [
      'well-groomed', 'disheveled', 'unkempt', 'scruffy', 'neat', 'tidy', 'messy', 'elegant', 'refined',
      'rugged', 'delicate', 'feminine', 'masculine', 'androgynous', 'boyish', 'girlish', 'matronly', 'distinguished'
    ]
  };

  const allDescriptors = Object.values(descriptorPatterns).flat();

  const parseEpub = async (file) => {
    if (!window.JSZip) {
      throw new Error('JSZip library not loaded');
    }

    const arrayBuffer = await file.arrayBuffer();
    const zip = await window.JSZip.loadAsync(arrayBuffer);
    
    let textContent = '';
    
    const htmlFiles = Object.keys(zip.files).filter(name => 
      (name.match(/\.(xhtml|html|htm)$/i)) && 
      !name.includes('nav') && 
      !name.includes('toc') &&
      !name.includes('cover')
    );
    
    htmlFiles.sort();
    
    for (const filename of htmlFiles) {
      const content = await zip.files[filename].async('text');
      const parser = new DOMParser();
      const doc = parser.parseFromString(content, 'text/html');
      
      doc.querySelectorAll('script, style').forEach(el => el.remove());
      
      const text = doc.body?.textContent || '';
      textContent += text + '\n\n';
    }
    
    return textContent;
  };

  const extractNames = (text) => {
    const sentences = text.split(/[.!?]+\s+/);
    const namePattern = /\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+)?\b/g;
    const nameCounts = {};
    
    sentences.forEach(sentence => {
      const matches = sentence.match(namePattern);
      if (matches) {
        matches.forEach(name => {
          if (name.length > 2 && !isCommonWord(name)) {
            nameCounts[name] = (nameCounts[name] || 0) + 1;
          }
        });
      }
    });
    
    const validNames = Object.entries(nameCounts)
      .filter(([_, count]) => count >= 3)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 30)
      .map(([name]) => name);
    
    return validNames;
  };

  const isCommonWord = (word) => {
    const commonWords = new Set([
      'The', 'And', 'But', 'Not', 'Chapter', 'Part', 'Book', 'Page', 'Yes', 'God',
      'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday',
      'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August',
      'September', 'October', 'November', 'December', 'Sir', 'Lady', 'Lord', 'King', 'Queen',
      'Mister', 'Miss', 'Mrs', 'Doctor', 'Professor', 'Captain', 'Colonel', 'General',
      'Please', 'Thank', 'What', 'When', 'Where', 'Why', 'How', 'Who', 'Which'
    ]);
    return commonWords.has(word);
  };

  const findDescriptions = (text, name) => {
    const paragraphs = text.split(/\n\n+/);
    const descriptions = new Map();
    
    paragraphs.forEach(paragraph => {
      const sentences = paragraph.split(/[.!?]+/).map(s => s.trim()).filter(s => s.length > 0);
      
      sentences.forEach((sentence, idx) => {
        const lowerSentence = sentence.toLowerCase();
        const namePattern = new RegExp(`\\b${name.toLowerCase()}\\b`, 'i');
        
        if (namePattern.test(lowerSentence)) {
          const hasDescriptor = allDescriptors.some(descriptor => 
            lowerSentence.includes(descriptor.toLowerCase())
          );
          
          if (hasDescriptor) {
            let context = sentence;
            if (idx < sentences.length - 1) {
              context += '. ' + sentences[idx + 1];
            }
            
            if (context.length > 15 && context.length < 400) {
              descriptions.set(context, true);
            }
          }
          
          const patterns = [
            new RegExp(`${name}\\s+(?:was|is|were|are|had|has|looked|appeared|seemed|stood)\\s+([^.!?]{15,200})`, 'i'),
            new RegExp(`(?:the|a|an)\\s+([^,]{15,100}?)\\s+${name}`, 'i'),
            new RegExp(`${name}'s\\s+([^.!?]{10,150})`, 'i'),
            new RegExp(`${name},?\\s+(?:who|with|whose)\\s+([^.!?,]{15,200})`, 'i'),
            new RegExp(`([^.!?]{15,100}?)\\s+(?:man|woman|person|boy|girl|lady|gentleman)\\s+(?:named|called)?\\s*${name}`, 'i'),
          ];
          
          patterns.forEach(pattern => {
            const match = sentence.match(pattern);
            if (match) {
              let desc = match[0].trim();
              desc = desc.replace(/\s+/g, ' ');
              
              if (desc.length > 15 && desc.length < 400) {
                descriptions.set(desc, true);
              }
            }
          });
          
          if (idx > 0) {
            const prevSentence = sentences[idx - 1];
            const combinedContext = prevSentence + '. ' + sentence;
            const hasDescriptor = allDescriptors.some(descriptor => 
              combinedContext.toLowerCase().includes(descriptor.toLowerCase())
            );
            if (hasDescriptor && combinedContext.length < 400) {
              descriptions.set(combinedContext, true);
            }
          }
        }
      });
    });
    
    return Array.from(descriptions.keys()).slice(0, 8);
  };

  const categorizeDescriptions = (descriptions) => {
    const categorized = {};
    
    descriptions.forEach(desc => {
      const lowerDesc = desc.toLowerCase();
      
      Object.entries(descriptorPatterns).forEach(([category, descriptors]) => {
        descriptors.forEach(descriptor => {
          if (lowerDesc.includes(descriptor.toLowerCase())) {
            if (!categorized[category]) {
              categorized[category] = new Set();
            }
            categorized[category].add(desc);
          }
        });
      });
    });
    
    Object.keys(categorized).forEach(key => {
      categorized[key] = Array.from(categorized[key]);
    });
    
    return categorized;
  };

  const handleFileUpload = async (e) => {
    const uploadedFile = e.target.files[0];
    if (!uploadedFile) return;
    
    if (!uploadedFile.name.endsWith('.epub')) {
      setError('Please upload an EPUB file');
      return;
    }

    if (!jszipLoaded) {
      setError('Library still loading, please wait a moment and try again');
      return;
    }
    
    setFile(uploadedFile);
    setError('');
    setCharacters([]);
    setAnalyzing(true);
    
    try {
      const text = await parseEpub(uploadedFile);
      
      if (text.length < 100) {
        setError('EPUB file appears to be empty or unreadable');
        setAnalyzing(false);
        return;
      }
      
      const names = extractNames(text);
      
      const characterData = names.map(name => {
        const descriptions = findDescriptions(text, name);
        const categorized = categorizeDescriptions(descriptions);
        
        return {
          name,
          descriptions,
          categorized,
          descriptionCount: descriptions.length
        };
      });
      
      const filteredCharacters = characterData.filter(c => c.descriptionCount > 0);
      filteredCharacters.sort((a, b) => b.descriptionCount - a.descriptionCount);
      
      setCharacters(filteredCharacters);
      
      if (filteredCharacters.length === 0) {
        setError('No character descriptions found. This book may not contain detailed physical descriptions.');
      }
    } catch (err) {
      setError('Error analyzing EPUB: ' + err.message);
      console.error(err);
    } finally {
      setAnalyzing(false);
    }
  };

  const exportToJSON = () => {
    const dataStr = JSON.stringify(characters, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `${file.name.replace('.epub', '')}_characters.json`;
    link.click();
    URL.revokeObjectURL(url);
  };

  const categoryLabels = {
    body: 'Body Shape & Build',
    chest: 'Chest & Torso',
    height: 'Height',
    hair: 'Hair',
    eyes: 'Eyes',
    skin: 'Skin',
    face: 'Facial Features',
    facialHair: 'Facial Hair',
    bodyParts: 'Body Parts',
    age: 'Age',
    marks: 'Distinguishing Marks',
    overall: 'Overall Appearance'
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-purple-50 via-blue-50 to-indigo-100 p-4 md:p-8">
      <div className="max-w-6xl mx-auto">
        <div className="bg-white rounded-xl shadow-2xl p-6 md:p-8">
          <div className="flex items-center gap-3 mb-6">
            <Book className="w-8 h-8 text-indigo-600" />
            <h1 className="text-3xl font-bold text-gray-800">EPUB Character Analyzer</h1>
          </div>
          
          <p className="text-gray-600 mb-6">
            Upload an EPUB file to extract detailed character descriptions including body shape, facial features, and physical attributes using advanced pattern matching.
          </p>

          {!jszipLoaded && (
            <div className="flex items-center gap-2 p-4 mb-6 bg-blue-50 border border-blue-200 rounded-lg">
              <div className="inline-block animate-spin rounded-full h-5 w-5 border-2 border-blue-200 border-t-blue-600"></div>
              <p className="text-blue-800">Loading required libraries...</p>
            </div>
          )}
          
          <div className="mb-8">
            <label className="flex flex-col items-center justify-center w-full h-32 border-2 border-dashed border-indigo-300 rounded-lg cursor-pointer hover:bg-indigo-50 transition-colors">
              <div className="flex flex-col items-center justify-center pt-5 pb-6">
                <Upload className="w-10 h-10 text-indigo-500 mb-2" />
                <p className="text-sm text-gray-600">
                  {file ? file.name : 'Click to upload EPUB file'}
                </p>
              </div>
              <input
                type="file"
                className="hidden"
                accept=".epub"
                onChange={handleFileUpload}
                disabled={!jszipLoaded}
              />
            </label>
          </div>
          
          {error && (
            <div className="flex items-center gap-2 p-4 mb-6 bg-red-50 border border-red-200 rounded-lg">
              <AlertCircle className="w-5 h-5 text-red-600 flex-shrink-0" />
              <p className="text-red-800">{error}</p>
            </div>
          )}
          
          {analyzing && (
            <div className="text-center py-12">
              <div className="inline-block animate-spin rounded-full h-12 w-12 border-4 border-indigo-200 border-t-indigo-600"></div>
              <p className="mt-4 text-gray-600">Analyzing EPUB file and extracting character descriptions...</p>
              <p className="mt-2 text-sm text-gray-500">This may take a moment for larger files</p>
            </div>
          )}
          
          {characters.length > 0 && !analyzing && (
            <div>
              <div className="flex justify-between items-center mb-6">
                <h2 className="text-2xl font-bold text-gray-800 flex items-center gap-2">
                  <User className="w-6 h-6 text-indigo-600" />
                  Characters Found ({characters.length})
                </h2>
                <button
                  onClick={exportToJSON}
                  className="flex items-center gap-2 px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors"
                >
                  <Download className="w-4 h-4" />
                  Export JSON
                </button>
              </div>
              
              <div className="space-y-8">
                {characters.map((character, idx) => (
                  <div key={idx} className="bg-gradient-to-br from-indigo-50 to-purple-50 rounded-xl p-6 border border-indigo-200 shadow-md">
                    <h3 className="text-2xl font-bold text-indigo-900 mb-4">
                      {character.name}
                    </h3>
                    
                    <div className="mb-4">
                      <span className="inline-block px-3 py-1 bg-indigo-600 text-white text-sm rounded-full">
                        {character.descriptionCount} description{character.descriptionCount !== 1 ? 's' : ''} found
                      </span>
                    </div>
                    
                    {Object.keys(character.categorized).length > 0 && (
                      <div className="mb-6">
                        <h4 className="font-semibold text-indigo-800 mb-3">Categories Found:</h4>
                        <div className="flex flex-wrap gap-2">
                          {Object.keys(character.categorized).map(category => (
                            <span key={category} className="px-3 py-1 bg-purple-100 text-purple-800 text-sm rounded-full border border-purple-300">
                              {categoryLabels[category] || category}
                            </span>
                          ))}
                        </div>
                      </div>
                    )}
                    
                    <div className="space-y-3">
                      <h4 className="font-semibold text-gray-700 mb-2">Physical Descriptions:</h4>
                      {character.descriptions.map((desc, i) => (
                        <div key={i} className="bg-white p-4 rounded-lg border border-indigo-100 shadow-sm">
                          <p className="text-gray-700 leading-relaxed">
                            {desc}
                          </p>
                        </div>
                      ))}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>
        
        <div className="mt-6 text-center text-sm text-gray-600 bg-white rounded-lg p-4 shadow">
          <p className="font-semibold mb-2">Advanced Pattern Matching</p>
          <p>Analyzes 150+ physical descriptors across 12 categories including body shape, facial features, and distinguishing characteristics</p>
        </div>
      </div>
    </div>
  );
};

export default EpubCharacterAnalyzer;
